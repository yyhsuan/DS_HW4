  int twocook(Queue &cook1, Queue &cook2, Queue &cancel, Queue &Timeout) {
    const int MAXQ = 3; // 每個佇列最多 3 筆訂單
    Node *it = head;
    int total_delay = 0;
    if (it == nullptr) return 0;

    // 主時間軸，採事件驅動：下一事件是 next arrival 或 next completion
    int cur_time = it->Arrival;
    // 將兩位廚師的 now_time 初始化到第一到達
    if (cook1.now_time < cur_time) cook1.now_time = cur_time;
    if (cook2.now_time < cur_time) cook2.now_time = cur_time;

    // 追蹤目前每位廚師正在處理的 job 的結束時間；-1 表示無工作
    int finish1 = -1, finish2 = -1;
    int start1 = -1, start2 = -1; // 各 job 的實際開始時間（用於 Delay 計算）

    // 幫助函式：把到 cur_time 的 arrivals 一個一個分配（依題意的 SQF）
    auto handle_arrivals_at = [&](int t) {
      while (it != nullptr && it->Arrival == t) {
        // 忽略非法訂單
        if (it->Duration <= 0 || it->Arrival + it->Duration > it->Timeout) {
          it = it->next;
          continue;
        }
        // 判斷閒置：佇列空且 now_time <= arrival
        bool idle1 = (cook1.size() == 0 && cook1.now_time <= it->Arrival);
        bool idle2 = (cook2.size() == 0 && cook2.now_time <= it->Arrival);

        if (idle1 && !idle2) {
          cook1.enquene(it->OID, it->Arrival, it->Duration, it->Timeout, 0, 0, 0, 1);
        } else if (!idle1 && idle2) {
          cook2.enquene(it->OID, it->Arrival, it->Duration, it->Timeout, 0, 0, 0, 2);
        } else if (idle1 && idle2) {
          // both idle -> choose 1
          cook1.enquene(it->OID, it->Arrival, it->Duration, it->Timeout, 0, 0, 0, 1);
        } else {
          // both not idle
          if (cook1.size() < MAXQ || cook2.size() < MAXQ) {
            // choose shorter queue; tie -> cook1
            if (cook1.size() <= cook2.size()) {
              cook1.enquene(it->OID, it->Arrival, it->Duration, it->Timeout, 0, 0, 0, 1);
            } else {
              cook2.enquene(it->OID, it->Arrival, it->Duration, it->Timeout, 0, 0, 0, 2);
            }
          } else {
            // both full -> immediate cancel (CID = 0)
            int Abort = it->Arrival;
            int Delay = 0;
            cancel.enquene(it->OID, it->Arrival, it->Duration, it->Timeout, Abort, Delay, 0, 0);
          }
        }
        it = it->next;
      }
    };

    // 初始處理：把第一批同時間到的訂單放進佇列
    handle_arrivals_at(cur_time);

    // 主要事件迴圈
    while (it != nullptr || cook1.size() > 0 || cook2.size() > 0 || finish1 != -1 || finish2 != -1) {
      // 若某廚師無工作且佇列有工作 -> 取出佇列頭開始做（設定 start/finish）
      if (finish1 == -1 && cook1.size() > 0) {
        Node *job = cook1.head;
        int s = cook1.now_time;
        if (s < job->Arrival) s = job->Arrival;
        if (s < cur_time) s = cur_time;
        start1 = s;
        finish1 = s + job->Duration;
        cook1.now_time = finish1;
      }
      if (finish2 == -1 && cook2.size() > 0) {
        Node *job = cook2.head;
        int s = cook2.now_time;
        if (s < job->Arrival) s = job->Arrival;
        if (s < cur_time) s = cur_time;
        start2 = s;
        finish2 = s + job->Duration;
        cook2.now_time = finish2;
      }

      // 下一個事件時間：下一到達 or 最早完成
      int nextArrival = (it != nullptr) ? it->Arrival : INT_MAX;
      int nextFinish = INT_MAX;
      if (finish1 != -1) nextFinish = std::min(nextFinish, finish1);
      if (finish2 != -1) nextFinish = std::min(nextFinish, finish2);
      int nextTime = std::min(nextArrival, nextFinish);

      // 若下一事件是到達且等於目前時間 -> 先處理到達（避免漏判）
      if (nextTime == cur_time && nextArrival == cur_time) {
        handle_arrivals_at(cur_time);
        // 重新計算下一事件
        nextArrival = (it != nullptr) ? it->Arrival : INT_MAX;
        nextFinish = INT_MAX;
        if (finish1 != -1) nextFinish = std::min(nextFinish, finish1);
        if (finish2 != -1) nextFinish = std::min(nextFinish, finish2);
        nextTime = std::min(nextArrival, nextFinish);
      }

      if (nextTime == INT_MAX) break; // no more events

      // 如果下一個事件是完成，先前進到那個時間並處理完成（可能兩個同時完成）
      // 若下一事件是到達且早於完成，先前進到到達並處理到達
      if (nextTime == nextFinish && nextFinish <= nextArrival) {
        // advance to nextFinish
        cur_time = nextFinish;
        // 處理完成事件（若同時兩個完成，兩個都處理）
        if (finish1 != -1 && finish1 == cur_time && cook1.size() > 0) {
          Node *job = cook1.head;
          int Departure = finish1;
          if (job->Timeout < Departure) {
            int Delay = start1 - job->Arrival;
            if (Delay < 0) Delay = 0;
            total_delay += Delay;
            Timeout.enquene(job->OID, job->Arrival, job->Duration, job->Timeout, 0, Delay, Departure, job->CID);
          }
          cook1.dequene();
          finish1 = -1;
          start1 = -1;
        }
        if (finish2 != -1 && finish2 == cur_time && cook2.size() > 0) {
          Node *job = cook2.head;
          int Departure = finish2;
          if (job->Timeout < Departure) {
            int Delay = start2 - job->Arrival;
            if (Delay < 0) Delay = 0;
            total_delay += Delay;
            Timeout.enquene(job->OID, job->Arrival, job->Duration, job->Timeout, 0, Delay, Departure, job->CID);
          }
          cook2.dequene();
          finish2 = -1;
          start2 = -1;
        }
        // 完成後，**同時間點**也可能有新的到達，要在同時間處理到達（題目規範）
        handle_arrivals_at(cur_time);
      } else {
        // 下一事件為到達（且早於任何完成）
        cur_time = nextArrival;
        handle_arrivals_at(cur_time);
      }
      // loop 回去，會再次安排沒有開始的工作
    } // end while

    return total_delay;
  }
